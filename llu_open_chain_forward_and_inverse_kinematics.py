# -*- coding: utf-8 -*-
"""llu_Open-Chain Forward and Inverse Kinematics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I8KPCHcuBe1QCwFiL5tTpu0FcHzvKgOd

# Homework 3: 6-DoF Open-chain Arm Forward and Inverse Kinematics

<img src="https://github.com/DARoSLab/Adv_robot_dyn_ctrl/blob/main/Figures/arm.png?raw=true" width="400">


*Note: In the given code base, the Jupyter visualizer make a single robot instance. Therefore, once you update the robot's posture, every robot in the multiple windows changes posture. Not an error, so no need to worry about it.
"""

#install meshcat visualizer
!git clone https://github.com/RussTedrake/meshcat-python --branch colab --recursive
!pip3 install u-msgpack-python
!git clone https://github.com/DARoSLab/Adv_robot_dyn_ctrl
import sys
sys.path.append('/content/meshcat-python/src')

#Python libraries
from meshcat.jupyter import JupyterVisualizer
import meshcat.geometry as g
import meshcat.transformations as tf
from meshcat.geometry import Box, Mesh, Sphere, MeshLambertMaterial, DaeMeshGeometry
import numpy as np
import os
import time
mesh_path =  '/content/Adv_robot_dyn_ctrl/Meshes/'

"""**[helper function] SE geration function: from RPY and xyz to SE(3)**"""

def generate_transformation_matrix(xyz=[0,0,0], rpy=[0,0,0]):
    Rx = tf.rotation_matrix(rpy[0], [1, 0, 0])[:3, :3]
    Ry = tf.rotation_matrix(rpy[1], [0, 1, 0])[:3, :3]
    Rz = tf.rotation_matrix(rpy[2], [0, 0, 1])[:3, :3]

    R = np.matmul(Rz, np.matmul(Ry, Rx))
    T = np.zeros((4,4))
    T[:3, :3] = R
    T[0, 3] = xyz[0]
    T[1, 3] = xyz[1]
    T[2, 3] = xyz[2]
    T[3, 3] = 1.0
    return T

"""**[helper function] Visualize robot**"""

def visualize_robot():
  vis = JupyterVisualizer()

  vis["arm/base"].set_object(
      g.DaeMeshGeometry.from_file(
          os.path.join(mesh_path, 'arm_base.dae')), MeshLambertMaterial(color=0xA7A7A7))
  vis["arm/base/link1"].set_object(
      g.DaeMeshGeometry.from_file(
          os.path.join(mesh_path, 'arm_link1.dae')), MeshLambertMaterial(color=0x424242)
  )
  vis["arm/base/link1/link2"].set_object(
      g.DaeMeshGeometry.from_file(
          os.path.join(mesh_path, 'arm_link2.dae')), MeshLambertMaterial(color=0x3633FF)
  )
  vis["arm/base/link1/link2/link3"].set_object(
      g.DaeMeshGeometry.from_file(
          os.path.join(mesh_path, 'arm_link3.dae')), MeshLambertMaterial(color=0xf25c19)
  )
  vis["arm/base/link1/link2/link3/link4"].set_object(
      g.DaeMeshGeometry.from_file(
          os.path.join(mesh_path, 'arm_link4.dae')), MeshLambertMaterial(color=0x000000)
  )
  vis["arm/base/link1/link2/link3/link4/link5"].set_object(
      g.DaeMeshGeometry.from_file(
          os.path.join(mesh_path, 'arm_link5.dae')), MeshLambertMaterial(color=0xA7A7A7)
  )
  vis["arm/base/link1/link2/link3/link4/link5/ee"].set_object(
      g.DaeMeshGeometry.from_file(
          os.path.join(mesh_path, 'arm_ee.dae')), MeshLambertMaterial(color=0xFF4265)
  )
  return vis

"""# Q.1 (a) [10 pts] Assemble the robot based on the diagram and complete a forward kinematics function
<img src="https://github.com/DARoSLab/CS403-Intro-Robotics/blob/main/figures/robot-configuration.png?raw=true" width="600">

Complete forward kinematics function below. You need to finding the joint position and orientation description (SE(3)) from each joint frame. These joint to next joint definitions will be used for visualization of the openchain. Once implementation is done (correctly), you will see the mainpualtor at zero posture.
"""

def ForwardKinematics(vis, q=[0, 0, 0, 0, 0, 0]):
  # Fill your code here
  base_to_joint1 = generate_transformation_matrix(xyz=[0,0,0], rpy=[0,0,q[0]])
  joint1_to_joint2 = generate_transformation_matrix(xyz=[0,0,0.15], rpy=[0,q[1],0])
  joint2_to_joint3 = generate_transformation_matrix(xyz=[0.23,0,0], rpy=[0,q[2],0])
  joint3_to_joint4 = generate_transformation_matrix(xyz=[0.13,0,0], rpy=[q[3],0,0])
  joint4_to_joint5 = generate_transformation_matrix(xyz=[0.09,0,0], rpy=[0,q[4],0])
  joint5_to_joint6 = generate_transformation_matrix(xyz=[0.06,0,0], rpy=[q[5],0,0])
  joint6_to_ee = generate_transformation_matrix(xyz=[0.045,0,0], rpy=[0,0,0])

  vis["arm/base/link1"].set_transform(base_to_joint1)
  vis["arm/base/link1/link2"].set_transform(joint1_to_joint2)
  vis["arm/base/link1/link2/link3"].set_transform(joint2_to_joint3)
  vis["arm/base/link1/link2/link3/link4"].set_transform(joint3_to_joint4)
  vis["arm/base/link1/link2/link3/link4/link5"].set_transform(joint4_to_joint5)
  vis["arm/base/link1/link2/link3/link4/link5/ee"].set_transform(joint5_to_joint6)


  # base_to_ee = np.matmul(joint6_to_ee, np.matmul(joint5_to_joint6, np.matmul(joint4_to_joint5, np.matmul(joint3_to_joint4, np.matmul(joint2_to_joint3, np.matmul(base_to_joint1, joint1_to_joint2))))))
  base_to_ee = base_to_joint1 @ joint1_to_joint2 @ joint2_to_joint3 @ joint3_to_joint4 @ joint4_to_joint5 @ joint5_to_joint6 @ joint6_to_ee
  return base_to_ee

vis = visualize_robot()
EE = ForwardKinematics(vis)

"""# Q 1.(b) [10 pts] Test the implemented forward kinematics function with your own test configurations and compare the results with your expectation.
1. List the configurations and expected end-effector position/orientation that you select (at least two configurations should be tested)
2. Give a short explanation why you choose the configuration
"""

q_test1 = [0,0,0,0,0,0]
EE = ForwardKinematics(vis, q = q_test1)
print(EE)

q_test2 = [0,-np.pi/2,0,0,0,0]
EE = ForwardKinematics(vis, q = q_test2)
print(EE)

q_test3 = [np.pi/2,-np.pi/2,np.pi/2,np.pi/2,np.pi/2,-np.pi/2]
EE = ForwardKinematics(vis, q = q_test3)
print(EE)

ForwardKinematics(vis, q = q_test1)

"""I have selected the zero position (q = [0, 0, 0, 0, 0, 0]) as the first configuration for testing. The zero position allows us to perform a baseline test to the function since it is the easiest to calculate and the least likely to go wrong.

Then I have selected the position q = [0, -pi/2, 0, 0, 0, 0], which we know that is just pointing the end-effector upwards towards the sky. This would give us a easy position to calculate, and just one rotation to perform.

Lastly, I went ahead to add a joint angle to all joints (q = [pi/2, -pi/2, pi/2, pi/2, pi/2, -pi/2]) to make sure that all joints are calculated properly.

# Q.2 [5 pts] Move the robot to the two given configurations and printout the end-effector position (3-dim vector) and orientation (SO(3))in both configurations.


1.   $q_1 =(0, \frac{π}{4}, 0.5, 0.5, 0, 0)$
2.   $q_2 =(\frac{π}{2}, \frac{π}{6}, 0.0, 0.5, 0, \frac{π}{8})$
"""

# vis = visualize_robot()
# q = [0, 0, 0, 0, 0, 0]
# EE = ForwardKinematics(vis, q=q)
# print(EE)

vis = visualize_robot()
print("Configuration 1: ")
q1 = [0, np.pi/4, 0.5, 0.5, 0, 0]
EE1 = ForwardKinematics(vis, q=q1)
print(EE1[:3, :3])
print(EE1[:3, 3])

print("Configuration 2: ")
q2 = [np.pi/2, np.pi/6, 0, 0.5, 0, np.pi/8]
EE2 = ForwardKinematics(vis, q=q2)
print(EE2[:3, :3])
print(EE2[:3, 3])

"""# Q3 [10 pts]. Animate the robot moving from $q_0→q_f$ where.
\begin{align}
\mathbf{q}_{0} &= [0, 0, 0, 0, 0, 0]\\
\mathbf{q}_{f} &= [0.8, 0, -0.5, -0.5, 1.2, 0]\\
\end{align}
**Use linear interpolation to obtain the intermediate configurations. i.e $\mathbf{q}(\alpha)=(1-\alpha)\mathbf{q}_0 + \alpha*\mathbf{q}_f$ where $\alpha \in [0, 1]$**
"""

vis = visualize_robot()
qi = np.array([0,0,0,0,0,0])
qf = np.array([0.8,0,-0.d5,-0.5,1.2,0])
# ForwardKinematics(vis, q=qi)

for alpha in np.linspace(0,1,100):
  q_alpha = (1-alpha)*qi + alpha*qf
  ForwardKinematics(vis, q=q_alpha)
  time.sleep(0.05)

# ForwardKinematics(vis, q=qf)

"""# Q4 [35 pts]. Implement a function that computes both World (explicit) and Body (implicit) Jacobians."""

# Utility functions (No need to change)
def skew_sym_matrix(a):
  return np.array([[0, -a[2], a[1]],
                   [a[2], 0, -a[0]],
                   [-a[1], a[0], 0]])

def inverse_transformation(T):
  R = np.transpose(T[:3, :3])
  p = -R@T[:3,3]
  v = np.array([0,0,0,1])
  return np.vstack((np.hstack((R,p.reshape((3,1)))), v))

# inverse_transformation(np.array([[1,2,3,4],[2,3,4,5],[3,4,5,6],[0,0,0,1]]))

"""## Q.4 (a) [15pt] Complete the following codes computing Jacobian at a given joint position.

We first build functions to generate the sequence of SE(3) and an adjoint matrix.

> ***make_SE3_from_joint_to_EE(q)***: This function will return a list of seven SE(3)s started from $_{0}T_{EE}$, where 0 means the global frame and EE means the end effector frame.
Then, the last six SE(3)s are $_{1}T_{EE}$, $_{2}T_{EE}$, ..., $_{6}T_{EE}$, where 1, 2, ..., 6 means the first, second, ..., sixth joint frame.

> ***Adj(T)***: The Adj function return $6\times 6$ adjoint matrix given SE(3)
"""

def make_SE3_from_joint_to_EE(q):
    T = {}
    # Fill your code to find the T(i_ee), i is equal to joint idx (1 - 6)
    T01 = generate_transformation_matrix(xyz=[0,0,0], rpy=[0,0,0])
    T12 = generate_transformation_matrix(xyz=[0,0,0.15], rpy=[0,0,q[0]])
    T23 = generate_transformation_matrix(xyz=[0.23,0,0], rpy=[0,q[1],0])
    T34 = generate_transformation_matrix(xyz=[0.13,0,0], rpy=[0,q[2],0])
    T45 = generate_transformation_matrix(xyz=[0.09,0,0], rpy=[q[3],0,0])
    T56 = generate_transformation_matrix(xyz=[0.06,0,0], rpy=[0,q[4],0])
    T6ee = generate_transformation_matrix(xyz=[0.045,0,0], rpy=[q[5],0,0])

    T[0] = T12@T23@T34@T45@T56@T6ee
    T[1] = T23@T34@T45@T56@T6ee
    T[2] = T34@T45@T56@T6ee
    T[3] = T45@T56@T6ee
    T[4] = T56@T6ee
    T[5] = T6ee
    T[6] = inverse_transformation(T01@T12@T23@T34@T45@T56@T6ee)
    # T[0] = inverse_transformation(T6ee@T56@T45@T34@T23@T12)
    # T[1] = inverse_transformation(T6ee@T56@T45@T34@T23)
    # T[2] = inverse_transformation(T6ee@T56@T45@T34)
    # T[3] = inverse_transformation(T6ee@T56@T45)
    # T[4] = inverse_transformation(T6ee@T56)
    # T[5] = inverse_transformation(T6ee)

    return T

def Adj(T):
    Adj_mtx = {}
    # Fill your code to make 6x6 adjoint mapping matrix from SE(3)
    for k in T.keys():
        adj = np.zeros((6,6))
        r = T[k][:3,:3]
        p = T[k][:3,3]
        adj[:3,:3] = r
        adj[3:,3:] = r
        adj[3:,:3] = skew_sym_matrix(p) @ r
        Adj_mtx[k] = adj

    return Adj_mtx

"""Then, complete the Jacobian function, which return Jacobian define in world or body frame depending on the given parameter."""

def Jacobian(q, coord='world'):

  T = make_SE3_from_joint_to_EE(q)
  S = {} # rotation axis at the local (joint) frame
  for i in range(6):
    S[i] = np.zeros(6)

  # Set S[i] = [w, -wxp] (No, only w no v...)
  x = np.array([1,0,0,0,0,0])
  y = np.array([0,1,0,0,0,0])
  z = np.array([0,0,1,0,0,0])
  S[0] = z
  S[1] = y
  S[2] = y
  S[3] = x
  S[4] = y
  S[5] = x

  J = np.zeros((6, 6))
  JB = np.zeros((6, 6))
  # Complete Jacobian computation
  adj_mtx = Adj(T)
  for i in range(6):
    JB[:, i] = adj_mtx[i]@S[i]

  if coord == "world":
    adj_w = np.zeros((6,6))
    adj_w[:3,:3] = T[6][:3,:3]
    adj_w[3:,3:] = T[6][:3,:3]
    for i in range(6):
      J[:, i] = adj_w@JB[:, i]
    # J = adj_w@JB
  else: J = JB

  return J

"""## Q.4.(b) [10 pts] Choose the test configuration and compare the result with your expectation. Shortly explain how you select the test configuration and Jacobian."""

# Debug the Jacobian function using your test configuration:
# q_test = np.zeros((6, 1))
q_test = ...

J = Jacobian(q_test, 'world')

np.set_printoptions(precision=3)
print(J)

"""(Write your explanation here)"""

# Test Jacobian function. Use for debugging (no need to change)
def test_Jacobian():
  test_q = {}
  q0 = np.zeros((6, 1))
  q1 = np.array([np.pi/2, 0, 0, -np.pi/4, np.pi/6, 0.8]).reshape(6, 1)
  q2 = np.array([0, 0, np.pi/2, 0.5, np.pi/6, 0]).reshape(6, 1)

  test_q[0] = q0
  test_q[1] = q1
  test_q[2] = q2
  res = []
  for i in range(3):
    res.append(Jacobian(test_q[i],'world'))

  for i in range(3):
    res.append(Jacobian(test_q[i],'body'))


  soln = np.load('/content/Adv_robot_dyn_ctrl/TestCode/jacobian_test.npy')
  if np.allclose(np.array(res), soln):
    print('Your implementation is correct')
  else:
    # print(np.array(res))
    # print()
    # print("soln: ")
    # print(soln)
    print('Your implementation is not correct try again')

test_Jacobian()

"""## Q.4.(c) [10 pts] Compute the end effector velocities associated with the following joint configurations and velocities.
\begin{align}
(a)\  q &=[0, 0, 0, 0, 0, 0] &\dot{q}=[1, 0, 0, 0, 0, 0]\\
(b)\  q &=[0, \frac{\pi}{4}, 0, \pi, 0, 0] &\dot{q}=[1, 0, 1, 0, 0, 0]\\
(c)\  q &=[\frac{\pi}{2}, \frac{\pi}{4}, 0, 0.5, 0, 0] &\dot{q}=[0, 0, 1, 0, 2, 1]\\
\end{align}
"""

# Fill your code
...

print('(a) vel = \n', vel_a)
print('(b) vel = \n', vel_b)
print('(c) vel = \n', vel_c)

"""# Q.5 [30 pts] Compute the joint configuration that corresponds to the following end-effector pose.
\begin{align}
P&=[0.2, 0.31, 0.2],\\
RPY&=[\frac{\pi}{2}, 0, 0].
\end{align}

## Q.5(a) [15 pts] Complete inverse kinematics function using world Jacobian.

First, complete the following function return so(3) (3-dim vector) from the given SO(3) (3x3 orientation matrix).
"""

def SO3toso3vec(R):
  omega, theta = None, 0
  if np.allclose(R, np.eye(3)): # if R = identity
    pass
  elif np.abs(np.trace(R)+1)<1e-5: # if theta = pi
    theta = np.pi
    r13 = R[0,2]
    r23 = R[1,2]
    r33 = R[2,2]
    omega = np.array([r13,r23, 1+r33])
    omega *= (1./np.sqrt(2*(1+r33)))
  else: # Other normal cases
    # Fill your code to compute so(3)
    ...

  so3vec = omega * theta
  return so3vec

"""Then complete the inverse kinematics function using the world Jacobian. The functions implemented above (e.g., make_SE3_from_joint_to_EE(q), SO3toso3vec) will be useful."""

def newton_raphson_world(T_des, q = np.zeros((6,1)), num_steps=50, lr=0.2):
  q_hist = [] # save the history of joint positions
  error_hist = [] #save the history of error (6-dim: orientation, position)
  for step in range(num_steps):
      J = Jacobian(q, 'world')
      err = np.zeros((6,1));

      # Your code will be here
      ...


      q_hist.append(q)
      error_hist.append(err)

      if np.linalg.norm(err) < 0.0001:
          break

  return q_hist, error_hist

# Test inverse kinematics (world Jacobian)
q0 = np.array([0.1, 0.3, -np.pi/2-0.9, -0.9, np.pi/2+0.3, 0.4]).reshape(6,1)
T_des = generate_transformation_matrix(xyz=[0.2, 0.31, 0.2], rpy=[np.pi/2,0,0])

N = 50
[q_hist, error_hist] = newton_raphson_world(T_des, q = q0, num_steps=N, lr=0.2)

# Visualization of results (no need to change)
vis = visualize_robot()
arrow_w = 0.005
arrow_h = 0.005
arrow_l = 0.1

vis["arm/ee_frame_x"].set_object(Mesh(Box([arrow_l, arrow_w, arrow_w]), MeshLambertMaterial(color=0xff0000)))
vis["arm/ee_frame_y"].set_object(Mesh(Box([arrow_w, arrow_l, arrow_w]), MeshLambertMaterial(color=0x00ff00)))
vis["arm/ee_frame_z"].set_object(Mesh(Box([arrow_w, arrow_w, arrow_l]), MeshLambertMaterial(color=0x0000ff)))

vis["arm/des_frame_x"].set_object(Mesh(Box([arrow_l, arrow_w, arrow_w]), MeshLambertMaterial(color=0xff0000)))
vis["arm/des_frame_y"].set_object(Mesh(Box([arrow_w, arrow_l, arrow_w]), MeshLambertMaterial(color=0x00ff00)))
vis["arm/des_frame_z"].set_object(Mesh(Box([arrow_w, arrow_w, arrow_l]), MeshLambertMaterial(color=0x0000ff)))

vis["arm/des_frame_x"].set_transform(T_des)
vis["arm/des_frame_y"].set_transform(T_des)
vis["arm/des_frame_z"].set_transform(T_des)

for i in range(len(q_hist)):
  Tee = ForwardKinematics(vis, q=q_hist[i])

  vis["arm/ee_frame_x"].set_transform(Tee)
  vis["arm/ee_frame_y"].set_transform(Tee)
  vis["arm/ee_frame_z"].set_transform(Tee)
  time.sleep(0.3)

print('T_ee: \n', Tee, '\n T_des: \n', T_des)

import matplotlib.pyplot as plt

error_hist_np = np.array(error_hist)
plt.plot(error_hist_np[:, 0], label='rx')
plt.plot(error_hist_np[:, 1], label='ry')
plt.plot(error_hist_np[:, 2], label='rz')
plt.plot(error_hist_np[:, 3], label='x')
plt.plot(error_hist_np[:, 4], label='y')
plt.plot(error_hist_np[:, 5], label='z')
plt.xlabel('k (iteration)')
plt.ylabel('Error (des - act)')
plt.legend()
plt.show()

"""## Q.6(b) [15 pts]. Complete inverse kinematics function using body Jacobian (Define the error implicitly)."""

def newton_raphson_body(T_des, q = np.zeros((6,1)), num_steps=50, lr=0.2):
  q_hist = []
  error_hist = []
  for step in range(num_steps):
      J = Jacobian(q, 'body')
      err = np.zeros((6,1));

      # Complete the code
      ...

      q_hist.append(q)
      error_hist.append(err)

      if np.linalg.norm(err) < 0.0001:
        break
  return q_hist, error_hist

# Test inverse kinematics (Body Jacobian)
N = 50
q0 = np.array([0.8, 0.4, -np.pi/2-0.4, -0.9, np.pi/2+0.3, 0.7]).reshape(6,1)

T_des = generate_transformation_matrix(xyz=[0.2, 0.31, 0.2], rpy=[np.pi/2,0,0])
[q_hist_imp, error_hist_imp] = newton_raphson_body(T_des, q = q0, num_steps=N, lr=0.2)
Tee_imp = None

vis = visualize_robot()
arrow_w = 0.005
arrow_h = 0.005
arrow_l = 0.1

vis["arm/ee_frame_x"].set_object(Mesh(Box([arrow_l, arrow_w, arrow_w]), MeshLambertMaterial(color=0xff0000)))
vis["arm/ee_frame_y"].set_object(Mesh(Box([arrow_w, arrow_l, arrow_w]), MeshLambertMaterial(color=0x00ff00)))
vis["arm/ee_frame_z"].set_object(Mesh(Box([arrow_w, arrow_w, arrow_l]), MeshLambertMaterial(color=0x0000ff)))

vis["arm/des_frame_x"].set_object(Mesh(Box([arrow_l, arrow_w, arrow_w]), MeshLambertMaterial(color=0xff0000)))
vis["arm/des_frame_y"].set_object(Mesh(Box([arrow_w, arrow_l, arrow_w]), MeshLambertMaterial(color=0x00ff00)))
vis["arm/des_frame_z"].set_object(Mesh(Box([arrow_w, arrow_w, arrow_l]), MeshLambertMaterial(color=0x0000ff)))

vis["arm/des_frame_x"].set_transform(T_des)
vis["arm/des_frame_y"].set_transform(T_des)
vis["arm/des_frame_z"].set_transform(T_des)

for i in range(len(q_hist_imp)):
  Tee_imp = ForwardKinematics(vis, q=q_hist_imp[i])
  vis["arm/ee_frame_x"].set_transform(Tee_imp)
  vis["arm/ee_frame_y"].set_transform(Tee_imp)
  vis["arm/ee_frame_z"].set_transform(Tee_imp)
  time.sleep(0.2)

print('T_ee: \n', Tee_imp, '\n T_des: \n', T_des)

error_hist_imp_np = np.array(error_hist_imp)
plt.plot(error_hist_imp_np[:, 0], label='rx')
plt.plot(error_hist_imp_np[:, 1], label='ry')
plt.plot(error_hist_imp_np[:, 2], label='rz')
plt.plot(error_hist_imp_np[:, 3], label='x')
plt.plot(error_hist_imp_np[:, 4], label='y')
plt.plot(error_hist_imp_np[:, 5], label='z')
plt.xlabel('k')
plt.ylabel('Error (des - act)')
plt.legend()
plt.show()